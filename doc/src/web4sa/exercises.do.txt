!split
======= Exercises =======

===== Exercise: Add two numbers =====
label{wf:exer:add2}
file=add2.tar.gz

Make a web application that reads two numbers from a web page,
adds the numbers, and prints the sum in a new web page.
Package the necessary files that constitute the application
in a tar file.

===== Exercise: Plot a user-specified formula =====
label{wf:exer:formula}
file=plot_formula.tar.gz

!bhint
You may use the `vib1` app from Section ref{wf:vib1:flask:app}
as starting point.
!ehint

===== Exercise: Visualize Taylor polynomial approximations =====
label{wf:exer:Taylor}
file=Taylor_approx.tar.gz

Make a web application that reads two numbers from a web page,
adds the numbers, and prints the sum in a new web page.
Package the necessary files that constitute the application
in a tar file.

!bc pyshell
>>> import compute
>>> import sympy as sp
>>> from sympy import *
>>> t = symbols('t')
>>> formula = exp(-2*t)
>>> f, s, latex = compute.formula2series2pyfunc(formula, 3, t)
>>> latex
'- \\frac{4 t^{3}}{3} + 2 t^{2} - 2 t + 1'
>>> imort matplotlib.pyplot as plot
>>> import numpy as np
>>> t = np.linspace(0, 2)
>>> plt.plot(t, f(t), t, s(t))
[<matplotlib.lines.Line2D at 0x7fc6c020f350>,
 <matplotlib.lines.Line2D at 0x7fc6c020f5d0>]
>>> plt.show()
!ec
The resulting plot is displayed below.

FIGURE: [fig-web4sa/Taylor_approx_exp2t, width=500 frac=0.8]

# #if TOPIC in ('Flask+Django', 'Flask')
===== Exercise: Extend the `vib3` app =====
label{wf:exer:vib3:demo}

Add a new argument `x_axis` to the `compute` function in the
"`vib3`": "${github_path}/src-web4sa/apps/flask_apps/vib3"
application from Section
ref{wf:vib3:flask:autogen}. The `x_axis` argument measures the extent
of the $x$ axis in the plots in terms of the number of standard
deviations (default may be 7).  Observe how the web interface
automatically adds the new argument and how the plots adapt!


===== Exercise: Equip the `vib3` app with more data types =====
label{wf:exer:vib3:lists}
file=vib3_ext.tar.gz

In the "`vib3`": "${github_path}/src-web4sa/apps/flask_apps/vib3"
application from Section ref{wf:vib3:flask:autogen},
use the `label` argument in the form field objects to add an
information of the type of data that is to be supplied in the
text field. Extend the `model.py` file to also handle
lists, tuples, and Numerical Python arrays. For these three
new data types, use a `TextField` object and run `eval`
on the text in the `view.py` file.
A simple test is to extend the `compute` function with an
argument `x_range` for the range of the $x$ axis, specified as
an interval (2-list or 2-tuple).


===== Exercise: Auto-generate code from function signature =====
file=generate_flask.py

Given a `compute` with a set of positional and keyword
arguments, the purpose of this exercise is to *automatically* generate the
Flask files `model.py` and `controller.py`. Use the Python `inspect`
module, see Section ref{wf:vib3:flask:autogen}, to extract
the positional and keyword arguments in `compute`, and use this
information to construct the relevant Python code in strings. Write
the strings to `model.py` and `controller.py` files. Assume as
in Section ref{wf:vib3:flask:autogen} that the user provides
a file `view_results.html` for defining how the returned object
from the `compute` function is to be rendered.

Test the code generator on the `compute` function in the `vib1`
application to check that the generated
`model.py` and `controller.py` files are correct.
# #endif
